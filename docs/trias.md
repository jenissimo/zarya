# Ассемблер ТРИАС

## Общее описание

ТРИАС (ТРоичный ИнтерпретируемыЙ АСсемблер) - это ассемблер для троичной ПОЛИЗ-машины Заря. Он обеспечивает:
- Трансляцию исходного кода в троичный код
- Поддержку меток и символьных имен
- Макросы и условную компиляцию
- Директивы ассемблера

## Синтаксис

### Структура программы
```asm
; Комментарии начинаются с точки с запятой

        .org 100     ; Директива начального адреса
start:              ; Метка
        PUSH #42    ; Инструкция
        POP  R0     ; Инструкция с операндом
        HALT        ; Останов
```

### Метки
- Должны начинаться с буквы
- Могут содержать буквы, цифры и знак подчеркивания
- Заканчиваются двоеточием
- Регистр символов имеет значение

### Операнды
1. Непосредственные значения:
   ```asm
   PUSH #42    ; Десятичное число
   PUSH #2A    ; Шестнадцатеричное число
   PUSH #101   ; Двоичное число
   PUSH #'A'   ; Символьная константа
   ```

2. Регистры:
   ```asm
   PUSH R0     ; Регистр R0
   POP  R1     ; Регистр R1
   ```

3. Косвенная адресация:
   ```asm
   PUSH @R0    ; Значение из памяти по адресу в R0
   POP  @R1    ; Сохранение в память по адресу в R1
   ```

## Директивы

### Размещение кода и данных
```asm
.org N      ; Установить адрес следующей инструкции
.align N    ; Выровнять на границу N трайтов
.space N    ; Зарезервировать N трайтов
```

### Определение данных
```asm
.trit -,0,+    ; Определить последовательность тритов
.tryte N       ; Определить трайт со значением N
.ascii "Text"  ; Определить строку в ASCII
```

### Макросы
```asm
.macro NAME [args]  ; Начало макроса
    ; Тело макроса
.endm              ; Конец макроса
```

### Условная компиляция
```asm
.if CONDITION      ; Начало условного блока
    ; Код при истинном условии
.else             ; Альтернативный блок
    ; Код при ложном условии
.endif            ; Конец условного блока
```

## Примеры программ

### Вычисление факториала
```asm
        .org 100
start:  
        PUSH #5      ; Вычислить 5!
        CALL fact
        INT  21      ; Вывести результат
        HALT

fact:   ; Вход: число на стеке
        ; Выход: факториал на стеке
        DUP
        PUSH #1
        EQ
        JZ   recur   ; Если не 1, рекурсия
        RET          ; Иначе возврат

recur:  DUP
        PUSH #1
        SUB         ; n-1
        CALL fact   ; Рекурсивный вызов
        MUL         ; n * fact(n-1)
        RET
```

### Вывод строки
```asm
        .org 100
start:  
        PUSH #msg    ; Адрес строки
next:   DUP
        LOAD
        DUP
        PUSH #0
        EQ
        JZ   print   ; Если не 0, печатать
        DROP
        DROP
        HALT

print:  INT  17      ; Вывод символа
        PUSH #1
        ADD         ; Следующий символ
        JMP  next

msg:    .ascii "Hello, World!"
        .tryte 0    ; Завершающий ноль
``` 