# Спецификация языка T

## Содержание

- [Спецификация языка T](#спецификация-языка-t)
  - [Содержание](#содержание)
  - [1. Введение](#1-введение)
  - [2. Лексическая структура](#2-лексическая-структура)
    - [2.1. Токены](#21-токены)
    - [2.2. Идентификаторы](#22-идентификаторы)
    - [2.3. Литералы](#23-литералы)
      - [2.3.1. Числовые литералы](#231-числовые-литералы)
      - [2.3.2. Тритовые литералы](#232-тритовые-литералы)
      - [2.3.3. Троичные системы счисления](#233-троичные-системы-счисления)
    - [2.4. Комментарии](#24-комментарии)
  - [3. Типы данных](#3-типы-данных)
    - [3.1. Примитивные типы](#31-примитивные-типы)
      - [3.1.1. `tryte`](#311-tryte)
      - [3.1.2. `word`](#312-word)
      - [3.1.3. `dword`](#313-dword)
      - [3.1.4. `float`](#314-float)
      - [3.1.5. `logic`](#315-logic)
      - [3.1.6. `string`](#316-string)
      - [3.1.7. `ptr`](#317-ptr)
      - [3.1.8. `void`](#318-void)
    - [3.2. Псевдонимы типов](#32-псевдонимы-типов)
  - [4. Переменные и объявления](#4-переменные-и-объявления)
  - [5. Операторы](#5-операторы)
    - [5.1. Арифметические операторы](#51-арифметические-операторы)
    - [5.2. Логические операторы](#52-логические-операторы)
    - [5.3. Операторы инкремента и декремента (`++`, `--`)](#53-операторы-инкремента-и-декремента----)
    - [5.4. Потритовые операторы (`<<`, `>>`)](#54-потритовые-операторы--)
    - [5.5. Операторы сравнения](#55-операторы-сравнения)
  - [6. Управляющие конструкции](#6-управляющие-конструкции)
    - [6.1. Условные операторы](#61-условные-операторы)
    - [6.2. Циклы](#62-циклы)
  - [7. Функции](#7-функции)
    - [7.1. Объявление функции](#71-объявление-функции)
    - [7.2. Вызов функции](#72-вызов-функции)
    - [7.3. Оператор return](#73-оператор-return)
  - [8. Указатели и управление памятью](#8-указатели-и-управление-памятью)
    - [8.1. Модель памяти](#81-модель-памяти)
    - [8.2. Объявление указателей](#82-объявление-указателей)
    - [8.3. Операции с указателями](#83-операции-с-указателями)
      - [8.3.1. Разыменование](#831-разыменование)
      - [8.3.2. Арифметика указателей](#832-арифметика-указателей)
    - [8.4. Безопасность и ограничения](#84-безопасность-и-ограничения)
    - [8.5. Примеры использования](#85-примеры-использования)
  - [9. Массивы](#9-массивы)
    - [9.1. Объявление массива](#91-объявление-массива)
    - [9.2. Доступ к элементам массива](#92-доступ-к-элементам-массива)
  - [10. Ввод/Вывод](#10-вводвывод)
    - [10.1. Функция `print()`](#101-функция-print)
  - [11. Стандартная библиотека](#11-стандартная-библиотека)
    - [11.1. Базовые константы](#111-базовые-константы)
    - [11.2. Троичные операции (`std.trit`)](#112-троичные-операции-stdtrit)
    - [11.3. Матричные операции (`std.matrix`)](#113-матричные-операции-stdmatrix)
    - [11.4. Троичная логика (`std.logic`)](#114-троичная-логика-stdlogic)
    - [11.5. Строковые операции (`std.string`)](#115-строковые-операции-stdstring)
    - [11.6. Ввод/вывод (`std.io`)](#116-вводвывод-stdio)
    - [11.7. Планируемые расширения](#117-планируемые-расширения)
  - [12. Примеры программ](#12-примеры-программ)
    - [12.1. Привет, мир!](#121-привет-мир)
    - [12.2. Вычисление площади круга](#122-вычисление-площади-круга)
    - [12.3. Управление логическими флагами](#123-управление-логическими-флагами)
  - [13. Обработка ошибок](#13-обработка-ошибок)
    - [13.1. Ошибки компиляции](#131-ошибки-компиляции)
    - [13.2. Ошибки времени выполнения](#132-ошибки-времени-выполнения)
    - [13.3. Обработка ошибок](#133-обработка-ошибок)
  - [14. Заметки по разработке](#14-заметки-по-разработке)
    - [14.1. Использование Bison и Flex](#141-использование-bison-и-flex)
    - [14.2. Сборка компилятора](#142-сборка-компилятора)
  - [15. Будущие улучшения](#15-будущие-улучшения)
  - [16. Приложение](#16-приложение)
    - [16.1. Зарезервированные ключевые слова](#161-зарезервированные-ключевые-слова)
    - [16.2. Приоритет операторов](#162-приоритет-операторов)
  - [17. Модульная организация](#17-модульная-организация)
    - [17.1. Модули и пространства имён](#171-модули-и-пространства-имён)
    - [17.2. Импорт и экспорт](#172-импорт-и-экспорт)
    - [17.3. Организация проекта](#173-организация-проекта)
    - [17.4. Стандартные модули](#174-стандартные-модули)
    - [17.5. Примеры использования](#175-примеры-использования)
    - [17.6. Рекомендации](#176-рекомендации)

## 1. Введение

**T** - это минималистичный, экзотический язык программирования, разработанный для архитектуры **Сетунь**, основанной на троичной сбалансированной системе счисления. Эмулируя уникальные особенности троичной логики, T расширяет привычный C-подобный синтаксис уникальными конструкциями, адаптированными для системы с трехзначной логикой.

## 2. Лексическая структура

### 2.1. Токены

Токены являются базовыми строительными блоками языка, представляющими ключевые слова, операторы, идентификаторы, литералы и другие синтаксические элементы.

### 2.2. Идентификаторы

Идентификаторы - это имена, присваиваемые переменным, функциям, типам и другим пользовательским сущностям. Они должны начинаться с буквы (`A-Z`, `a-z`) или подчеркивания (`_`), за которыми следует любая комбинация букв, цифр (`0-9`) или подчеркиваний.

**Примеры:**

```
radius
calc_area
sensor_flag
data_1
```

### 2.3. Литералы

#### 2.3.1. Числовые литералы

Числовые литералы представляют целые числа и числа с плавающей точкой.

**Целочисленные литералы:**
- Состоят из цифр `0-9`
- Могут быть положительными или отрицательными

**Литералы с плавающей точкой:**
- Содержат десятичную точку
- Представляют числа с дробной частью

**Примеры:**
```
42
-17
3.14
-0.001
```

#### 2.3.2. Тритовые литералы

Тритовые литералы явно представляют значения в сбалансированной троичной системе. Они начинаются с префикса `0t`, за которым следует последовательность тритов (`+`, `-`, `0`):

- `+`: Представляет `+1`
- `-`: Представляет `-1`
- `0`: Представляет `0`

**Синтаксис:**
```
0t[последовательность_тритов]
```

**Примеры:**
```
0t+0-+0  // Представляет последовательность тритов: +1, 0, -1, +1, 0
0t+++    // Представляет +1, +1, +1
0t0-+0   // Представляет 0, -1, +1, 0
```

#### 2.3.3. Троичные системы счисления

T поддерживает две системы представления троичных чисел: сбалансированную и несбалансированную.

**Сбалансированная система (STT - Symmetric Ternary T):**
- Каждый трит принимает одно из трёх значений: `-1` (`-`), `0` (`0`), `+1` (`+`)
- Литералы записываются в формате `0t` с символами `-`, `0`, `+`
- Является основной системой для арифметических операций
- Пример: `0t+0-+0` = (+1×3⁵) + (0×3⁴) + (-1×3³) + (+1×3²) + (0×3¹) + (0×3⁰) = 243 + 0 - 27 + 9 + 0 + 0 = 225

**Несбалансированная система (UTT - Unbalanced Ternary T):**
- Каждый трит принимает одно из трёх значений: `0`, `1`, `2`
- Литералы записываются в формате `0u` с цифрами `0`, `1`, `2`
- Используется преимущественно для адресации памяти и индексации
- Пример: `0u012` = (0×3²) + (1×3¹) + (2×3⁰) = 0 + 3 + 2 = 5

**Преобразование между системами:**
```
// Явное преобразование из STT в UTT
tryte balanced = 0t+0-;           // В STT: +1, 0, -1
tryte unbalanced = to_utt(balanced); // В UTT: 2, 1, 0

// Явное преобразование из UTT в STT
tryte unbalanced = 0u012;         // В UTT: 0, 1, 2
tryte balanced = to_stt(unbalanced); // В STT: -1, 0, +1
```

**Арифметические операции:**
1. **В сбалансированной системе:**
   ```
   tryte a = 0t+0-;    // +1, 0, -1
   tryte b = 0t0++;    // 0, +1, +1
   tryte sum = a + b;  // Результат в STT: +1, +1, 0
   ```

2. **В несбалансированной системе:**
   ```
   tryte x = 0u012;    // 0, 1, 2
   tryte y = 0u201;    // 2, 0, 1
   tryte sum = x + y;  // Результат в UTT: 2, 1, 0
   ```

**Использование систем:**
1. **Сбалансированная (STT):**
   - Арифметические вычисления
   - Логические операции
   - Представление знаковых чисел
   ```
   tryte value = 0t+0-;     // Явно сбалансированное
   if (value > 0t000) {     // Сравнение с нулём
       print("Положительное");
   }
   ```

2. **Несбалансированная (UTT):**
   - Адресация памяти
   - Индексы массивов
   - Размеры данных
   ```
   ptr address = 0u222;     // Адрес в памяти
   array[0u012] = value;    // Индекс массива
   ```

**Неявные преобразования:**
- При использовании десятичных литералов компилятор автоматически выбирает подходящую систему:
  ```
  tryte x = 5;      // Автоматически в STT: 0t+--
  ptr p = 5;        // Автоматически в UTT: 0u012
  ```

**Примечания:**
1. По умолчанию все арифметические операции выполняются в сбалансированной системе
2. Преобразование между системами требует явного вызова функций `to_stt()` или `to_utt()`
3. Использование неправильной системы для контекста вызывает ошибку компиляции
4. Литералы с префиксом `0t` всегда интерпретируются как сбалансированные
5. Литералы с префиксом `0u` всегда интерпретируются как несбалансированные

**Примеры ошибок:**
```
ptr address = 0t+0-;        // Ошибка: STT нельзя использовать для адресации
tryte index = 0u012;        // Ошибка: UTT нельзя использовать для арифметики
                           // без явного преобразования

// Правильно:
ptr address = 0u012;        // UTT для адресации
tryte index = to_stt(0u012); // Явное преобразование для арифметики
```

### 2.4. Комментарии

Комментарии - это неисполняемые утверждения, предназначенные для документации и пояснений в коде. T поддерживает однострочные комментарии.

**Синтаксис:**
```
// Это однострочный комментарий
```

**Пример:**
```
// Инициализация радиуса круга
tryte radius = +2;
```

## 3. Типы данных

T предлагает набор примитивных типов, адаптированных для троичной логики и сбалансированной троичной арифметики.

### 3.1. Примитивные типы

#### 3.1.1. `tryte`

- **Описание:** Представляет базовую единицу данных, аналогичную байту в двоичных системах
- **Размер:** 6 тритов
- **Диапазон:**
  - **Сбалансированный:** от -364 до +364
  - **Несбалансированный:** от 0 до 728
- **Использование:** Для малых целых чисел и флагов

**Пример:**
```
tryte x = 0t+0-+0;
```

#### 3.1.2. `word`

- **Описание:** Представляет слово, состоящее из нескольких трайтов
- **Размер:** 12 тритов (2 трайта)
- **Диапазон:**
  - **Сбалансированный:** от -265,720 до +265,720
  - **Несбалансированный:** от 0 до 531,441
- **Использование:** Для больших целых чисел и сложных флагов

**Пример:**
```
word data = 0t+0-+0++;
```

#### 3.1.3. `dword`

- **Описание:** Представляет двойное слово
- **Размер:** 24 трита (4 трайта)
- **Диапазон:**
  - **Сбалансированный:** от -141,214,768,240 до +141,214,768,240
  - **Несбалансированный:** от 0 до 282,429,536,481
- **Использование:** Для очень больших целых чисел и обширных структур данных
- **Примечание:** Диапазон основан на том, что 3^24 = 282,429,536,481, а сбалансированное представление даёт примерно половину этого диапазона в обе стороны от нуля

**Пример:**
```
dword largeNumber = 0t+0-+0-;  // Пример 6-тритового числа
```

#### 3.1.4. `float`

- **Описание:** Представляет числа с плавающей точкой
- **Размер:** 6 тритов (1 трайт)
- **Структура:**
  - **1 трит:** Знак (`+1` для положительных, `-1` для отрицательных)
  - **2 трита:** Экспонента (от -4 до +4)
  - **3 трита:** Мантисса (от -13 до +13)
- **Диапазон:** ±1.053 × 10³
- **Точность:** Приблизительно 0.0769

**Пример:**
```
float pi = 3.14;
float area = 0t+0-+0;
```

#### 3.1.5. `logic`

- **Описание:** Представляет троичную логику с тремя различными состояниями
- **Размер:** 1 трит
- **Состояния:**
  - **`true`** (`+1`): Представляет истинное условие
  - **`false`** (`-1`): Представляет ложное условие
  - **`?`** (`0`): Представляет неопределенное или нейтральное условие
- **Использование:** Для условных выражений и флагов

**Пример:**
```
logic flag = true;
logic uncertainty = ?;
logic error = false;
```

#### 3.1.6. `string`

- **Описание:** Представляет последовательности символов
- **Структура хранения:**
  - Строка состоит из последовательности символов типа `tchar`
  - Каждый `tchar` занимает один трайт (6 тритов)
  - Поддерживается кодировка UTF-8 с троичным представлением:
    - ASCII символы (0-127): используют 3 трита
    - Расширенные символы: используют от 3 до 6 тритов
  - Строка завершается специальным терминатором `0t---` (все триты -1)

- **Размер:**
  - Заголовок строки: 2 трайта (12 тритов)
    - Длина строки: 1 трайт (6 тритов)
    - Размер в памяти: 1 трайт (6 тритов)
  - Данные: N трайтов для символов + 1 трайт для терминатора

- **Операции:**
  ```
  // Создание строки
  string s = "Hello";  // Автоматическое преобразование литерала
  
  // Доступ к символам (только для чтения)
  tchar first = s[0];
  
  // Получение длины
  tryte len = s.length;  // Количество символов
  
  // Конкатенация
  string s1 = "Hello";
  string s2 = "World";
  string s3 = s1 + s2;  // "HelloWorld"
  
  // Сравнение
  if (s1 == s2) {  // Посимвольное сравнение
      print("Строки равны");
  }
  ```

- **Кодировка символов:**
  ```
  // ASCII символы (0-127)
  tchar a = 'a';    // 0t+0-  (97 в троичной системе)
  tchar Z = 'Z';    // 0t+-0  (90 в троичной системе)
  
  // Кириллица и другие Unicode символы
  tchar я = 'я';    // Использует все 6 тритов
  ```

- **Строковые литералы:**
  ```
  string s1 = "Простая строка";
  string s2 = "Строка с \"кавычками\"";
  string s3 = "Многострочная\nстрока";
  ```

- **Ограничения:**
  - Строки неизменяемы (immutable)
  - Максимальная длина: 364 символа (ограничение размера tryte)
  - Прямая модификация символов невозможна
  - Для изменения нужно создавать новую строку

- **Примеры использования:**
  ```
  // Пример 1: Базовые операции
  string name = "Заря";
  print("Длина:", name.length);  // Выведет: Длина: 4
  
  // Пример 2: Конкатенация
  string greeting = "Привет, " + name + "!";
  
  // Пример 3: Обработка строки
  fn process_string(string input) : void {
      for (tryte i = 0; i < input.length; i++) {
          tchar c = input[i];
          print("Символ", i, ":", c);
      }
  }
  
  // Пример 4: Сравнение строк
  string s1 = "abc";
  string s2 = "абв";
  if (s1.length != s2.length) {
      print("Разная длина");
  }
  ```

**Примечание:** В будущих версиях языка планируется:
- Поддержка строковых буферов для изменяемых строк
- Расширенные операции со строками (поиск, замена, регулярные выражения)
- Оптимизация хранения для длинных строк
- Улучшенная поддержка Unicode и локализации

#### 3.1.7. `ptr`

- **Описание:** Представляет указатели на адреса памяти
- **Размер:** 12 тритов (2 трайта)
- **Диапазон:** от 0 до 531,441 (несбалансированный)
- **Использование:** Для управления памятью и ссылок на переменные

**Пример:**
```
ptr p = &data;
```

#### 3.1.8. `void`

- **Описание:** Представляет отсутствие значения
- **Использование:** Для функций, которые не возвращают значение
- **Примечание:** Не может быть использован для объявления переменных

**Пример:**
```
fn print_hello() : void {
    print("Привет!");
}
```

### 3.2. Псевдонимы типов

Псевдонимы типов можно определять для упрощения или расширения существующих типов.

**Пример:**
```
typedef tryte small_int;
typedef word medium_int;
typedef dword large_int;
```

## 4. Переменные и объявления

Переменные объявляются путем указания типа, за которым следует идентификатор и необязательная инициализация.

**Синтаксис:**
```
тип идентификатор = значение;
```

**Примеры:**
```
tryte radius = 0t+0-+0;
float pi = 3.14;
logic status = true;
word data = 0t+++---;
ptr p = &radius;
```

## 5. Операторы

T поддерживает различные операторы, адаптированные для троичной логики и арифметики.

### 5.1. Арифметические операторы

Операторы для выполнения математических вычислений.

| Оператор | Описание | Пример |
|----------|----------|--------|
| `+` | Сложение | `a + b` |
| `-` | Вычитание | `a - b` |
| `*` | Умножение | `a * b` |
| `/` | Деление | `a / b` |
| `<<` | Сдвиг влево (×3) | `a << 1` |
| `>>` | Сдвиг вправо (÷3) | `a >> 1` |

**Примеры:**
```
tryte a = 0t+0-+0;
tryte b = 0t-+0-0;
tryte sum = a + b;
float area = pi * radius * radius;
word shifted = a << 1;
```

### 5.2. Логические операторы

Специальные операторы, разработанные для троичной логики.

| Оператор | Описание | Операция | Пример |
|----------|-----------|-----------|---------|
| `@` | Логическое И (`min`) | Возвращает минимум из двух значений | `a @ b` |
| `$` | Логическое ИЛИ (`max`) | Возвращает максимум из двух значений | `a $ b` |
| `~` | Логическое НЕ | Инвертирует логическое значение | `~a` |

**Таблица истинности для троичной логики:**

| A | B | A @ B | A $ B | ~A |
|---|---|-------|-------|-----|
| true  | true  | true  | true  | false |
| true  | ?     | ?     | true  | false |
| true  | false | false | true  | false |
| ?     | true  | ?     | true  | ?     |
| ?     | ?     | ?     | ?     | ?     |
| ?     | false | false | ?     | ?     |
| false | true  | false | true  | true  |
| false | ?     | false | ?     | true  |
| false | false | false | false | true  |

**Взаимодействие с условными конструкциями:**

1. **Поведение `if-elif-else` с троичной логикой:**
   ```
   if (условие1) {
       // Выполняется, если условие1 == true (+1)
   } elif (условие2) {
       // Выполняется, если условие1 == ? или false,
       // И условие2 == true
   } else {
       // Выполняется, если все предыдущие условия
       // вернули ? или false
   }
   ```

2. **Таблица выполнения условных блоков:**

   | Условие | Блок if | Блок elif | Блок else |
   |---------|----------|-----------|------------|
   | true    | ✓        | ✗         | ✗          |
   | ?       | ✗        | следующее условие | если все ? |
   | false   | ✗        | следующее условие | если все false |

3. **Примеры поведения:**
   ```
   // Пример 1: Простое условие
   logic x = ?;
   if (x) {
       print("Не выполнится");  // x == ? пропускает блок if
   } else {
       print("Выполнится");     // Выполняется, т.к. x != true
   }

   // Пример 2: Цепочка условий
   logic a = ?;
   logic b = true;
   if (a) {
       print("Блок 1");         // Не выполнится (a == ?)
   } elif (b) {
       print("Блок 2");         // Выполнится (b == true)
   } else {
       print("Блок 3");         // Не выполнится
   }

   // Пример 3: Все условия неопределены
   logic x = ?;
   logic y = ?;
   if (x) {
       print("Блок 1");         // Не выполнится (x == ?)
   } elif (y) {
       print("Блок 2");         // Не выполнится (y == ?)
   } else {
       print("Блок 3");         // Выполнится, т.к. все условия ?
   }
   ```

4. **Правила обработки неопределённости:**
   - Значение `?` в условии всегда пропускает текущий блок
   - Если все условия в цепочке `if-elif` вернули `?`, выполняется блок `else`
   - Нет неявного приведения `?` к `false`
   - Компилятор не выдаёт предупреждений при использовании `?` в условиях

5. **Сложные условия:**
   ```
   // Пример комбинации операторов
   logic a = true;
   logic b = ?;
   logic c = false;

   if (a @ b) {
       print("Не выполнится");     // true @ ? == ?
   } elif (b $ c) {
       print("Не выполнится");     // ? $ false == ?
   } elif (a $ ~c) {
       print("Выполнится");        // true $ true == true
   }
   ```

6. **Рекомендации по использованию:**
   ```
   // Явная проверка на неопределённость
   logic status = get_status();
   if (status == ?) {
       print("Статус неопределён");
   } elif (status == true) {
       print("Статус положительный");
   } elif (status == false) {
       print("Статус отрицательный");
   }

   // Обработка всех возможных состояний
   fn process_status(logic status) : void {
       switch (status) {
           case true:
               print("Активно");
               break;
           case ?:
               print("Неопределено");
               break;
           case false:
               print("Неактивно");
               break;
       }
   }
   ```

**Примечание:** Троичная логика в T спроектирована так, чтобы неопределённость (`?`) явно обрабатывалась в коде, а не приводилась неявно к `true` или `false`. Это помогает писать более надёжный код, где неопределённые состояния обрабатываются явно.

### 5.3. Операторы инкремента и декремента (`++`, `--`)

Операторы для изменения значений переменных. Поведение зависит от типа данных.

| Оператор | Описание | Пример |
|----------|-----------|---------|
| `++` | Инкремент | `x++` |
| `--` | Декремент | `x--` |

**Поведение для разных типов:**

1. **Для `logic`:**
   - `++`: Циклический переход по состояниям `false` → `?` → `true` → `false`
   - `--`: Циклический переход по состояниям `false` → `true` → `?` → `false`

2. **Для `tryte`:**
   - **Диапазон:** от -364 до +364
   - `++`: Увеличивает значение на 1, при достижении максимума переходит к минимуму
   - `--`: Уменьшает значение на 1, при достижении минимума переходит к максимуму
   ```
   tryte x = 364;
   x++;  // x = -364
   ```

3. **Для `word`:**
   - **Диапазон:** от -265,720 до +265,720
   - `++`: Стандартное увеличение на 1 с проверкой переполнения
   - `--`: Стандартное уменьшение на 1 с проверкой переполнения
   - При переполнении генерируется исключение `OverflowError`
   ```
   word x = 265720;
   x++;  // Вызовет OverflowError
   ```

4. **Для `dword`:**
   - **Диапазон:** от -141,214,768,240 до +141,214,768,240
   - `++`: Стандартное увеличение на 1 с проверкой переполнения
   - `--`: Стандартное уменьшение на 1 с проверкой переполнения
   - При переполнении генерируется исключение `OverflowError`
   ```
   dword x = -141214768240;
   x--;  // Вызовет OverflowError
   ```

5. **Для `ptr`:**
   - Инкремент и декремент изменяют адрес на размер типа, на который указывает указатель
   - При выходе за пределы допустимого адресного пространства генерируется исключение `SegmentationFault`
   ```
   tryte arr[3];
   ptr p = &arr[0];
   p++;  // Сдвиг на размер tryte (6 тритов)
   ```

**Примечания:**
- Циклическое поведение реализовано только для `logic` и `tryte`
- Для типов `word` и `dword` используется строгая арифметика с проверкой переполнения
- Для указателей инкремент/декремент работает с учётом размера типа данных
- Операторы не применимы к типам `float` и `string`

**Примеры:**
```
// Пример 1: Циклический инкремент tryte
tryte t = 364;
t++;        // t = -364
t--;        // t = 364

// Пример 2: Инкремент word с проверкой переполнения
word w = 265720;
try {
    w++;    // Вызовет OverflowError
} catch (OverflowError) {
    print("Произошло переполнение");
}

// Пример 3: Арифметика указателей
tryte data[5];
ptr p = &data[0];
p++;        // Переход к следующему tryte
*p = 0t+0-; // Запись в следующий элемент массива
```

### 5.4. Потритовые операторы (`<<`, `>>`)

Операторы для арифметического сдвига тритов, выполняющие умножение или деление на степени тройки.

| Оператор | Описание | Операция | Пример |
|----------|-----------|-----------|---------|
| `<<` | Троичный сдвиг влево | Умножает значение на 3 в степени N | `a << 2` умножает на 9 |
| `>>` | Троичный сдвиг вправо | Делит значение на 3 в степени N | `a >> 1` делит на 3 |

**Особенности:**
- В отличие от двоичных побитовых сдвигов, эти операторы выполняют именно арифметические операции
- Сохраняют знак числа при сдвиге
- Работают с тритами, а не с битами

**Примеры:**
```
tryte a = 0t+0-;     // Значение +3
a = a << 1;          // Станет +9 (3 * 3)
a = a >> 2;          // Станет +1 (9 / 9)

tryte b = 0t-0+;     // Отрицательное значение
b = b << 1;          // Умножится на 3, сохранив знак
```

**Примечание:** Эти операторы реализуют троичный арифметический сдвиг и не являются прямыми аналогами двоичных побитовых операторов.

### 5.5. Операторы сравнения

Операторы сравнения возвращают значение типа `logic`.

| Оператор | Описание | Пример |
|----------|----------|--------|
| `==` | Равно | `a == b` |
| `!=` | Не равно | `a != b` |
| `<` | Меньше | `a < b` |
| `>` | Больше | `a > b` |
| `<=` | Меньше или равно | `a <= b` |
| `>=` | Больше или равно | `a >= b` |

**Поведение для разных типов:**

1. **Для числовых типов (`tryte`, `word`, `dword`, `float`):**
   - Стандартное числовое сравнение
   - Результат: `true` (+1), `false` (-1)
   ```
   tryte a = 0t+0-;  // Положительное число
   tryte b = 0t-0+;  // Отрицательное число
   logic result = a > b;  // true
   ```

2. **Для типа `logic`:**
   - Порядок значений: `false` (-1) < `?` (0) < `true` (+1)
   - Операторы `==` и `!=` сравнивают точные значения
   - Операторы `<`, `>`, `<=`, `>=` используют указанный порядок
   ```
   logic a = true;   // +1
   logic b = ?;      // 0
   logic c = false;  // -1
   
   a > b;   // true  (true > ?)
   b > c;   // true  (? > false)
   a == b;  // false (true != ?)
   b != c;  // true  (? != false)
   c < b;   // true  (false < ?)
   ```

3. **Для указателей (`ptr`):**
   - Сравнение адресов в памяти
   - `==` и `!=` проверяют равенство адресов
   - `<`, `>`, `<=`, `>=` сравнивают числовые значения адресов
   ```
   tryte arr[3];
   ptr p1 = &arr[0];
   ptr p2 = &arr[1];
   logic result = p1 < p2;  // true (адрес p1 меньше адреса p2)
   ```

4. **Для строк (`string`):**
   - Поддерживаются только операторы `==` и `!=`
   - Сравнение происходит посимвольно
   ```
   string s1 = "Заря";
   string s2 = "Заря";
   logic result = s1 == s2;  // true
   ```

**Таблица результатов сравнения для типа `logic`:**

| Операция | false | ? | true |
|----------|--------|---|------|
| `false <` | false | true | true |
| `? <` | false | false | true |
| `true <` | false | false | false |
| `false ==` | true | false | false |
| `? ==` | false | true | false |
| `true ==` | false | false | true |

**Примечания:**
- Операторы сравнения всегда возвращают значение типа `logic`
- Для типа `logic` определён строгий порядок значений
- Сравнение разных типов требует явного приведения типов
- Попытка сравнения несовместимых типов вызывает ошибку компиляции

**Примеры:**
```
// Пример 1: Сравнение logic значений
logic a = true;
logic b = ?;
logic result = a > b;  // true (true > ?)

// Пример 2: Сравнение чисел
tryte x = 0t+0-;
tryte y = 0t-0+;
if (x >= y) {
    print("x больше или равно y");
}

// Пример 3: Сравнение указателей
tryte arr[3];
ptr p1 = &arr[0];
ptr p2 = &arr[1];
if (p1 < p2) {
    print("p1 указывает на младший адрес");
}

// Пример 4: Сравнение строк
string s1 = "Заря";
string s2 = "Сетунь";
if (s1 != s2) {
    print("Строки различны");
}
```

## 6. Управляющие конструкции

### 6.1. Условные операторы

Условные операторы позволяют выполнять ветвление на основе троичной логики.

**Синтаксис:**
```
if (условие) {
    // Блок кода для true (+1)
} elif (другое_условие) {
    // Блок кода для true (+1)
} else {
    // Блок кода для остальных случаев
}
```

**Правила вычисления условий:**

1. **Прямое использование троичных значений:**
   - Если выражение в условии равно `true` (+1) → выполняется соответствующий блок кода
   - Если выражение равно `false` (-1) → блок пропускается
   - Если выражение равно `?` (0) → блок пропускается и выполнение переходит к следующему условию

2. **Сложные логические выражения:**
   ```
   if (a @ b) {  // Выполнится только если оба операнда true
       // ...
   } elif (x $ y) {  // Выполнится если хотя бы один операнд true
       // ...
   } elif (z == ?) {  // Явное сравнение с неопределенным состоянием
       // ...
   }
   ```

3. **Неявное приведение типов:**
   - Числовые значения: 
     - Положительные → `true`
     - Отрицательные → `false`
     - Ноль → `?`
   - Указатели:
     - Ненулевые → `true`
     - Нулевые → `false`

**Примеры:**
```
// Пример 1: Прямое использование logic
logic flag = true;
if (flag) {  // Неявное использование значения
    print("Флаг истинный");
}

// Пример 2: Явное сравнение
if (flag == true) {  // Явное сравнение
    print("Флаг истинный");
} elif (flag == false) {
    print("Флаг ложный");
} elif (flag == ?) {
    print("Флаг в неопределенном состоянии");
}

// Пример 3: Сложное условие
logic a = true;
logic b = ?;
if (a @ b) {  // Результат: ? (не выполнится)
    print("Не будет выполнено");
} elif (a $ b) {  // Результат: true (выполнится)
    print("Будет выполнено");
}

// Пример 4: Неявное приведение числа
tryte x = 0t+--;  // Отрицательное значение
if (x) {  // Преобразуется в false
    print("Не будет выполнено");
} else {
    print("Будет выполнено");
}
```

**Примечание:** В отличие от традиционных языков программирования с двоичной логикой, в T условные операторы полностью поддерживают троичную логику, что позволяет более точно выражать неопределенные состояния и работать с ними.

### 6.2. Циклы

Циклы позволяют выполнять повторяющиеся действия.

**Цикл For:** Итерация по диапазону значений.

**Синтаксис:**
```
for (тип переменная = начало; условие; переменная = переменная + шаг) {
    // Блок кода
}
```

**Пример:**
```
for (tryte i = 0; i < 3; i++) {
    print("Индекс:", i);
}
```

**Цикл Loop (аналог While):** Выполняется, пока условие истинно.

**Синтаксис:**
```
loop (условие) {
    // Блок кода
}
```

**Пример:**
```
logic counter = 3;

loop (counter != 0) {
    print("Счетчик:", counter);
    counter--;
}
```

**Цикл For по диапазону:** Итерация по определенному диапазону.

**Синтаксис:**
```
for (переменная in начало..конец) {
    // Блок кода
}
```

**Пример:**
```
for (i in 1..5) {
    print("Значение:", i);
}
```

## 7. Функции

Функции инкапсулируют повторно используемые блоки кода.

### 7.1. Объявление функции

**Синтаксис:**
```
fn имя_функции(параметр1 : тип, параметр2 : тип, ...) : тип_возврата {
    // Тело функции
}
```

**Однострочная функция:** Для простых функций тело может быть определено с помощью оператора `=>`.

**Синтаксис:**
```
fn имя_функции(параметр1 : тип, ...) : тип_возврата => выражение;
```

**Примеры:**
```
fn calc_area(r : float) : float {
    return 3.14 * r * r;
}

fn square(x : float) : float => x * x;
```

### 7.2. Вызов функции

Функции вызываются по имени с передачей аргументов в скобках.

**Синтаксис:**
```
имя_функции(аргумент1, аргумент2, ...);
```

**Примеры:**
```
float area = calc_area(radius);
float sq = square(5.0);
```

### 7.3. Оператор return

Функции возвращают значения с помощью ключевого слова `return`.

**Синтаксис:**
```
return выражение;
```

**Пример:**
```
fn add(a : tryte, b : tryte) : tryte {
    return a + b;
}
```

## 8. Указатели и управление памятью

### 8.1. Модель памяти

- **Адресное пространство:**
  - Размер адреса: 12 тритов (2 трайта)
  - Диапазон адресов: от 0 до 531,441
  - Минимальная адресуемая единица: 1 трайт (6 тритов)

- **Выравнивание:**
  - `tryte`: 1 трайт (6 тритов)
  - `word`: 2 трайта (12 тритов)
  - `dword`: 4 трайта (24 трита)
  - `float`: 1 трайт (6 тритов)
  - `logic`: 1 трит (упаковывается по 6 в трайт)
  - `ptr`: 2 трайта (12 тритов)

### 8.2. Объявление указателей

**Синтаксис:**
```
ptr<тип> имя_указателя = &переменная;
```

**Примеры:**
```
tryte value = 0t+0-+0;
ptr<tryte> p1 = &value;        // Указатель на tryte
word array[5];
ptr<word> p2 = &array[0];      // Указатель на word
ptr<ptr<tryte>> pp = &p1;      // Указатель на указатель
```

### 8.3. Операции с указателями

#### 8.3.1. Разыменование

- **Базовое разыменование:**
  ```
  тип значение = *указатель;
  ```

- **Разыменование с учётом типа:**
  - Система автоматически учитывает размер типа при разыменовании
  - При разыменовании считывается нужное количество трайтов
  ```
  word* pw = &some_word;
  word w = *pw;     // Считывает 2 трайта (12 тритов)
  dword* pd = &some_dword;
  dword d = *pd;    // Считывает 4 трайта (24 трита)
  ```

#### 8.3.2. Арифметика указателей

1. **Инкремент/декремент:**
   - Изменяет адрес на размер базового типа
   ```
   ptr<tryte> pt = &tryte_array[0];
   pt++;            // Адрес увеличивается на 1 трайт (6 тритов)
   
   ptr<word> pw = &word_array[0];
   pw++;            // Адрес увеличивается на 2 трайта (12 тритов)
   
   ptr<dword> pd = &dword_array[0];
   pd++;            // Адрес увеличивается на 4 трайта (24 трита)
   ```

2. **Сложение/вычитание:**
   - Адрес изменяется на N * размер_типа
   ```
   ptr<word> p = &word_array[0];
   p = p + 3;       // Адрес увеличивается на 3 * 2 трайта
   ```

3. **Разность указателей:**
   - Возвращает количество элементов между указателями
   ```
   ptr<tryte> p1 = &array[0];
   ptr<tryte> p2 = &array[5];
   tryte diff = p2 - p1;  // diff = 5
   ```

### 8.4. Безопасность и ограничения

1. **Проверки времени выполнения:**
   - Выход за границы адресного пространства
   - Нарушение выравнивания
   - Доступ к неинициализированной памяти

2. **Исключения:**
   ```
   try {
       ptr<word> p = &array[0];
       p = p + 1000;     // SegmentationFault если адрес > 531,441
       word value = *p;  // SegmentationFault при неверном доступе
   } catch (SegmentationFault) {
       print("Ошибка доступа к памяти");
   }
   ```

3. **Ограничения:**
   - Запрет арифметики указателей разных типов
   - Запрет преобразования между указателями без явного приведения
   - Невозможность создания указателя на произвольный адрес

### 8.5. Примеры использования

```
// Пример 1: Работа с массивом через указатель
word array[5] = {1, 2, 3, 4, 5};
ptr<word> p = &array[0];

for (tryte i = 0; i < 5; i++) {
    print(*p);     // Разыменование с учётом размера word
    p++;           // Переход к следующему word (+=12 тритов)
}

// Пример 2: Копирование памяти
fn copy_memory(ptr<void> dest, ptr<void> src, tryte size) : void {
    ptr<tryte> d = dest;
    ptr<tryte> s = src;
    for (tryte i = 0; i < size; i++) {
        *d = *s;   // Копирование по трайту
        d++;
        s++;
    }
}

// Пример 3: Работа с многомерным массивом
word matrix[3][3];
ptr<word> row = &matrix[1][0];  // Указатель на начало второй строки
for (tryte i = 0; i < 3; i++) {
    *row = i;      // Заполнение строки
    row++;         // Переход к следующему элементу (+=12 тритов)
}
```

**Примечание:** При работе с указателями важно учитывать размер типа и выравнивание данных для корректного доступа к памяти.

## 9. Массивы

### 9.1. Объявление массива

**Синтаксис:**
```
тип имя_массива[размер] = {элемент1, элемент2, ..., элементN};
```

**Примеры:**
```
word numbers[3] = {0t+0-+0, 0t+++--, 0t-0+0-};
float measurements[5];
```

### 9.2. Доступ к элементам массива

Доступ к элементам осуществляется с помощью индекса в квадратных скобках.

**Синтаксис:**
```
имя_массива[индекс]
```

**Проверка границ:**
- При доступе к элементам массива выполняются следующие проверки времени выполнения:
  1. **Отрицательные индексы:**
     - Любой отрицательный индекс вызывает исключение `ArrayBoundError`
     - Это включает случаи неявного получения отрицательного индекса в троичной арифметике
  
  2. **Выход за верхнюю границу:**
     - Индекс >= размера массива вызывает исключение `ArrayBoundError`
     - Размер проверяется в тритах с учётом размера типа элементов

  3. **Неинициализированные индексы:**
     - Использование неинициализированной переменной в качестве индекса вызывает `UninitializedError`

**Примеры:**
```
// Пример 1: Базовый доступ
word numbers[3] = {0t+0-+0, 0t+++--, 0t-0+0-};
word first = numbers[0];     // OK
word last = numbers[2];      // OK

// Пример 2: Отрицательный индекс
tryte i = 0t----0;          // Отрицательное число
try {
    word value = numbers[i]; // Вызовет ArrayBoundError
} catch (ArrayBoundError) {
    print("Отрицательный индекс");
}

// Пример 3: Выход за границу
try {
    word value = numbers[3]; // Вызовет ArrayBoundError
} catch (ArrayBoundError) {
    print("Индекс больше размера массива");
}

// Пример 4: Троичная арифметика в индексах
tryte index = 0t+0-+0;      // Положительное число
index = -index;             // Стал отрицательным
try {
    word value = numbers[index]; // Вызовет ArrayBoundError
} catch (ArrayBoundError) {
    print("Индекс стал отрицательным из-за троичной арифметики");
}
```

**Рекомендации по безопасности:**
1. Всегда проверяйте индексы перед доступом:
   ```
   tryte i = calculate_index();
   if (i >= 0 && i < array_size) {
       value = array[i];
   } else {
       print("Индекс вне допустимого диапазона");
   }
   ```

2. Используйте безопасные итерации:
   ```
   for (tryte i = 0; i < array_size; i++) {
       // Индекс гарантированно в пределах массива
       process(array[i]);
   }
   ```

3. Учитывайте особенности троичной арифметики:
   ```
   // Потенциально опасно:
   tryte i = some_index;
   i = -i;  // Может стать отрицательным
   
   // Безопасно:
   if (i >= 0) {
       i = -i;  // Проверили перед инверсией
   }
   ```

## 10. Ввод/Вывод

### 10.1. Функция `print()`

Выводит данные в консоль.

**Синтаксис:**
```
print(выражение1, выражение2, ..., выражениеN);
```

**Примеры:**
```
print("Привет, мир!");
print("Значение x:", x);
print("Площадь:", area);
```

**Поведение:**
- Объединяет несколько выражений пробелами
- Автоматически преобразует типы в их строковое представление

## 11. Стандартная библиотека

T предоставляет обширную стандартную библиотеку для работы с троичными вычислениями и базовыми структурами данных.

### 11.1. Базовые константы

**Математические константы** (`std.math.constants`):
```
// Троичные дроби
pub const TRIT_HALF: tryte = 0t+00;     // Троичная 1/2
pub const TRIT_THIRD: tryte = 0t0+-;    // Троичная 1/3
pub const TRIT_NINTH: tryte = 0t00+;    // Троичная 1/9

// Математические константы
pub const PI: float = 3.14159;          // π
pub const E: float = 2.71828;           // Число e
pub const SQRT3: float = 1.73205;       // Корень из 3

// Системные константы
pub const MAX_TRYTE: tryte = 0t+++++;   // Максимальное значение tryte
pub const MIN_TRYTE: tryte = 0t----;    // Минимальное значение tryte
pub const TRIT_ZERO: tryte = 0t00000;   // Нулевой трайт
```

### 11.2. Троичные операции (`std.trit`)

**Манипуляции с тритами:**
```
// Базовые операции с тритами
pub fn get_trit(value: tryte, position: tryte) : logic;  // Получить трит
pub fn set_trit(value: tryte, position: tryte, trit: logic) : tryte;  // Установить трит
pub fn count_trits(value: tryte) : tryte;  // Подсчёт значащих тритов

// Троичные преобразования
pub fn to_balanced(value: tryte) : tryte;    // В сбалансированную форму
pub fn to_unbalanced(value: tryte) : tryte;  // В несбалансированную форму
pub fn rotate_trits(value: tryte, shift: tryte) : tryte;  // Циклический сдвиг тритов

// Троичная арифметика
pub fn trit_add(a: tryte, b: tryte) : tryte;      // Сложение по тритам
pub fn trit_multiply(a: tryte, b: tryte) : tryte;  // Умножение по тритам
pub fn trit_divide(a: tryte, b: tryte) : tryte;    // Деление по тритам
```

### 11.3. Матричные операции (`std.matrix`)

**Работа с троичными матрицами:**
```
// Типы данных
pub type Matrix = {
    rows: tryte,
    cols: tryte,
    data: ptr<tryte>
};

// Создание и уничтожение
pub fn create_matrix(rows: tryte, cols: tryte) : Matrix;
pub fn delete_matrix(matrix: Matrix) : void;

// Базовые операции
pub fn get_element(matrix: Matrix, row: tryte, col: tryte) : tryte;
pub fn set_element(matrix: Matrix, row: tryte, col: tryte, value: tryte) : void;
pub fn transpose(matrix: Matrix) : Matrix;

// Матричная арифметика
pub fn add_matrix(a: Matrix, b: Matrix) : Matrix;
pub fn multiply_matrix(a: Matrix, b: Matrix) : Matrix;
pub fn scale_matrix(matrix: Matrix, factor: tryte) : Matrix;

// Специальные матрицы
pub fn identity_matrix(size: tryte) : Matrix;  // Единичная матрица
pub fn zero_matrix(rows: tryte, cols: tryte) : Matrix;  // Нулевая матрица
```

### 11.4. Троичная логика (`std.logic`)

**Расширенные логические операции:**
```
// Тернарные операторы
pub fn consensus(a: logic, b: logic, c: logic) : logic;  // Консенсус
pub fn any(values: ptr<logic>, count: tryte) : logic;    // Хотя бы одно true
pub fn all(values: ptr<logic>, count: tryte) : logic;    // Все true
pub fn none(values: ptr<logic>, count: tryte) : logic;   // Все false

// Преобразования
pub fn to_string(value: logic) : string;  // В строковое представление
pub fn from_string(str: string) : logic;  // Из строки
```

### 11.5. Строковые операции (`std.string`)

**Расширенная работа со строками:**
```
// Манипуляции
pub fn substring(str: string, start: tryte, length: tryte) : string;
pub fn concat(str1: string, str2: string) : string;
pub fn replace(str: string, old: string, new: string) : string;

// Поиск
pub fn find(str: string, substr: string) : tryte;
pub fn find_last(str: string, substr: string) : tryte;

// Преобразования
pub fn to_upper(str: string) : string;
pub fn to_lower(str: string) : string;
pub fn trim(str: string) : string;
```

### 11.6. Ввод/вывод (`std.io`)

**Расширенные операции ввода/вывода:**
```
// Консольный ввод/вывод
pub fn print_trit(value: tryte);  // Вывод в троичном формате
pub fn read_trit() : tryte;       // Ввод троичного числа
pub fn print_matrix(matrix: Matrix);  // Вывод матрицы

// Файловые операции
pub fn read_file(path: string) : string;
pub fn write_file(path: string, content: string) : void;
pub fn append_file(path: string, content: string) : void;
```

### 11.7. Планируемые расширения

1. **Троичная криптография:**
   - Хеш-функции на основе троичной логики
   - Троичное шифрование
   - Генерация троичных псевдослучайных чисел

2. **Троичные структуры данных:**
   - Троичные деревья
   - Троичные хеш-таблицы
   - Троичные графы

3. **Научные вычисления:**
   - Троичная линейная алгебра
   - Троичные преобразования Фурье
   - Троичная оптимизация

4. **Параллельные вычисления:**
   - Троичные атомарные операции
   - Троичная синхронизация
   - Параллельные троичные алгоритмы

5. **Сетевые операции:**
   - Троичное кодирование данных
   - Протоколы передачи троичных данных
   - Троичная сериализация

**Примечание:** Все планируемые расширения будут реализованы с учётом особенностей троичной логики и оптимизированы для работы на троичной архитектуре.

## 12. Примеры программ

### 12.1. Привет, мир!

Простая программа, которая выводит "Привет, мир!".

```
fn main() : void {
    print("Привет, мир!");
}
```

**Вывод:**
```
Привет, мир!
```

### 12.2. Вычисление площади круга

Вычисляет площадь круга по заданному радиусу.

```
fn calc_area(r : float) : float {
    return 3.14 * r * r;
}

fn main() : void {
    float radius = 5.0;
    float area = calc_area(radius);
    print("Площадь круга равна:", area);
}
```

**Вывод:**
```
Площадь круга равна: 78.5
```

### 12.3. Управление логическими флагами

Демонстрирует использование типа `logic` и флагов на основе тритов.

```
fn main() : void {
    // Инициализация логических флагов
    logic sensor1 = true;
    logic sensor2 = ?;
    logic sensor3 = false;

    // Вывод состояний датчиков
    print("Датчик 1:", sensor1);
    print("Датчик 2:", sensor2);
    print("Датчик 3:", sensor3);

    // Логические операции
    logic overall_status = sensor1 @ sensor2 @ ~sensor3;  // Логическое И и НЕ
    print("Общий статус системы:", overall_status);

    // Проверка условий
    if (overall_status == true) {
        print("Система работает.");
    } elif (overall_status == false) {
        print("В системе критические ошибки.");
    } else {
        print("Статус системы неопределен.");
    }
}
```

**Вывод:**
```
Датчик 1: true
Датчик 2: ?
Датчик 3: false
Общий статус системы: ?
Статус системы неопределен.
```

## 13. Обработка ошибок

T использует механизмы обработки ошибок как во время компиляции, так и во время выполнения.

### 13.1. Ошибки компиляции

Ошибки, обнаруженные во время фаз парсинга и компиляции, такие как синтаксические ошибки, несоответствие типов и необъявленные переменные.

**Пример:**
```
fn main() : void {
    tryte x = 0t+0-+0;
    float y = "неверно";  // Ошибка несоответствия типов
}
```

**Вывод ошибки:**
```
Ошибка: Несоответствие типов: невозможно присвоить строку типу float.
```

### 13.2. Ошибки времени выполнения

Ошибки, возникающие во время выполнения программы, такие как деление на ноль, неверный доступ к памяти и логические ошибки.

**Пример:**
```
fn main() : void {
    float a = 10.0;
    float b = 0.0;
    float c = a / b;  // Деление на ноль
    print(c);
}
```

**Вывод ошибки:**
```
Ошибка времени выполнения: Деление на ноль.
```

### 13.3. Обработка ошибок

- **Механизм Try-Catch:** (Опционально) Введение обработки исключений для изящного управления ошибками.

**Синтаксис:**
```
try {
    // Код, который может вызвать ошибку
} catch (тип_ошибки) {
    // Код обработки ошибки
}
```

**Пример:**
```
fn main() : void {
    try {
        float result = 10.0 / 0.0;
        print(result);
    } catch (DivisionByZero) {
        print("Ошибка: Деление на ноль невозможно.");
    }
}
```

*Примечание:* Обработка исключений является опциональной расширенной функцией и может быть добавлена в будущих улучшениях.

## 14. Заметки по разработке

### 14.1. Использование Bison и Flex

**Bison** и **Flex** рекомендуются как инструменты для разработки компилятора или интерпретатора для T.

- **Bison:** Используется для определения грамматики и генерации парсера.
- **Flex:** Используется для лексического анализа, токенизации исходного кода.

**Шаги настройки:**

1. **Определение грамматики (Bison):**
   - Создание файла `.y` с описанием синтаксических правил
   - Определение токенов и правил продукции на основе спецификации языка

2. **Определение лексера (Flex):**
   - Создание файла `.l` для определения шаблонов токенов
   - Включение поддержки тритовых литералов (`0t0-+0`)

3. **Генерация парсера и лексера:**
   - Запуск Bison и Flex для генерации исходных файлов C/C++

4. **Компиляция компилятора/интерпретатора:**
   - Использование компилятора C/C++ для сборки финального исполняемого файла

**Пример команд:**
```bash
bison -d parser.y
flex lexer.l
gcc -o t-compiler parser.tab.c lex.yy.c -lfl
```

### 14.2. Сборка компилятора

1. **Установка Bison и Flex:**
   - На системах на базе Debian:
     ```bash
     sudo apt-get install bison flex
     ```

2. **Создание файлов грамматики и лексера:**
   - `parser.y`: Содержит грамматику Bison
   - `lexer.l`: Содержит определения лексера Flex

3. **Генерация исходных файлов:**
   ```bash
   bison -d parser.y
   flex lexer.l
   ```

4. **Компиляция:**
   ```bash
   gcc -o t-compiler parser.tab.c lex.yy.c -lfl
   ```

5. **Запуск компилятора:**
   ```bash
   ./t-compiler source.t
   ```

*Примечание:* Компилятор должен быть расширен семантическим анализом, генерацией кода и поддержкой времени выполнения на основе спецификации языка.

## 15. Будущие улучшения

1. **Расширенные типы данных:**
   - Введение структур (`struct`), объединений (`union`) и перечислений (`enum`) для сложных представлений данных

2. **Управление памятью:**
   - Реализация динамического выделения памяти (`allocate()`, `deallocate()`)

3. **Расширение стандартной библиотеки:**
   - Предоставление комплексной стандартной библиотеки с утилитами для математики, манипуляции строками и др.

4. **Обработка исключений:**
   - Добавление надежных механизмов обработки ошибок, включая блоки try-catch и пользовательские исключения

5. **Объектно-ориентированные возможности:**
   - Введение классов, наследования и полиморфизма для модульного и повторно используемого кода

6. **Параллелизм:**
   - Реализация многопоточности и примитивов синхронизации для параллельной обработки

7. **Оптимизация:**
   - Оптимизация компилятора для улучшения производительности и уменьшения использования памяти

8. **Интеграция с T-DOS:**
   - Разработка системных вызовов и API для взаимодействия с минимальной DOS-подобной операционной системой

## 16. Приложение

### 16.1. Зарезервированные ключевые слова

Следующие ключевые слова зарезервированы и не могут использоваться как идентификаторы:

```
fn, if, elif, else, for, loop, print, true, false, ?, tryte, word, dword, float, logic, string, ptr, void
```

### 16.2. Приоритет операторов

Операторы имеют следующий приоритет (от высшего к низшему):

1. `~` (Логическое НЕ)
2. `*`, `/` (Умножение и деление)
3. `+`, `-` (Сложение и вычитание)
4. `@`, `$` (Логическое И и ИЛИ)
5. `<`, `>`, `<=`, `>=`, `==`, `!=` (Операторы сравнения)
6. `&&`, `||` (Логическое И, ИЛИ в C-подобном синтаксисе или их T-специфичные эквиваленты)
7. `=` (Присваивание)

**Примечание:** Скобки `()` могут использоваться для переопределения приоритета.

**Пример:**
```
logic a = true @ false $ ~maybe;
```

Интерпретируется как:
```
logic a = (true @ false) $ (~maybe);
``` 

## 17. Модульная организация

### 17.1. Модули и пространства имён

Модульная система T организована иерархически, с поддержкой пространств имён для избежания конфликтов имён.

**Объявление модуля:**
```
module имя_модуля;  // Должно быть первой строкой файла

// Импорт других модулей
import math;
import io.console;
import std.string;

// Объявление пространства имён
namespace имя_пространства {
    // Содержимое пространства имён
}
```

**Структура модуля:**
1. **Заголовочные файлы** (`.th`):
   ```
   // math.th
   module math;
   
   // Публичные объявления
   pub fn sqrt(x: float) : float;
   pub fn pow(base: float, exp: float) : float;
   
   // Константы
   pub const PI: float = 3.14159;
   
   // Типы
   pub type Vector = {
       x: float,
       y: float,
       z: float
   };
   ```

2. **Файлы реализации** (`.t`):
   ```
   // math.t
   module math;
   
   // Приватные функции
   fn calculate_newton(x: float) : float {
       // Реализация
   }
   
   // Реализация публичных функций
   pub fn sqrt(x: float) : float {
       return calculate_newton(x);
   }
   ```

### 17.2. Импорт и экспорт

**Варианты импорта:**
```
// Импорт всего модуля
import math;
import io.console;

// Выборочный импорт
from math import sqrt, pow;

// Импорт с переименованием
import long.module.name as short;

// Импорт всех публичных элементов
from math import *;  // Не рекомендуется
```

**Правила видимости:**
```
module example;

// Публичный интерфейс
pub fn public_function() : void {
    private_function();  // OK
}

// Приватная реализация
fn private_function() : void {
    // Доступна только внутри модуля
}

// Публичные константы
pub const VERSION: string = "1.0";

// Приватные константы
const INTERNAL_FLAG: logic = true;
```

### 17.3. Организация проекта

**Структура каталогов:**
```
project/
├── src/
│   ├── main.t
│   ├── math/
│   │   ├── vector.th
│   │   ├── vector.t
│   │   └── matrix.t
│   └── io/
│       ├── console.th
│       └── console.t
├── lib/
│   └── external_lib/
└── build/
```

**Файл конфигурации проекта** (`project.tconfig`):
```
name: "project_name"
version: "1.0.0"
author: "Author Name"

dependencies:
    math_lib: "^1.0.0"
    io_lib: "^2.1.0"

modules:
    - src/math
    - src/io
```

### 17.4. Стандартные модули

T предоставляет набор стандартных модулей:

1. **std.core:**
   ```
   import std.core;  // Базовые типы и функции
   ```

2. **std.math:**
   ```
   import std.math;  // Математические функции
   
   fn main() : void {
       float root = math.sqrt(9.0);
       float power = math.pow(2.0, 3.0);
   }
   ```

3. **std.io:**
   ```
   import std.io;  // Ввод/вывод
   
   fn main() : void {
       string input = io.readline();
       io.print("Вы ввели:", input);
   }
   ```

### 17.5. Примеры использования

**Пример 1: Создание и использование модуля:**
```
// vector.th
module math.vector;

pub type Vector3 = {
    x: float,
    y: float,
    z: float
};

pub fn create(x: float, y: float, z: float) : Vector3;
pub fn length(v: Vector3) : float;

// vector.t
module math.vector;

pub fn create(x: float, y: float, z: float) : Vector3 {
    return Vector3 { x: x, y: y, z: z };
}

pub fn length(v: Vector3) : float {
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

// main.t
module main;

import math.vector;

fn main() : void {
    let v = vector.create(1.0, 2.0, 3.0);
    print("Длина вектора:", vector.length(v));
}
```

**Пример 2: Пространства имён:**
```
namespace graphics {
    pub type Color = {
        r: tryte,
        g: tryte,
        b: tryte
    };
    
    pub fn create_color(r: tryte, g: tryte, b: tryte) : Color {
        return Color { r: r, g: g, b: b };
    }
}

namespace math {
    pub fn lerp(a: float, b: float, t: float) : float {
        return a + (b - a) * t;
    }
}

// Использование
fn main() : void {
    let color = graphics.create_color(0t+++, 0t000, 0t---);
    let value = math.lerp(0.0, 1.0, 0.5);
}
```

### 17.6. Рекомендации

1. **Организация кода:**
   - Разделяйте интерфейс (`.th`) и реализацию (`.t`)
   - Группируйте связанные функции в модули
   - Используйте пространства имён для логического разделения

2. **Именование:**
   - Используйте осмысленные имена модулей
   - Избегайте конфликтов имён через пространства имён
   - Следуйте соглашению: маленькие буквы для модулей

3. **Видимость:**
   - Делайте публичными только необходимые элементы
   - Используйте приватные функции для внутренней логики
   - Документируйте публичный API

4. **Зависимости:**
   - Минимизируйте внешние зависимости
   - Явно указывайте версии зависимостей
   - Используйте выборочный импорт вместо `import *`